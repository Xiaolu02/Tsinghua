<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€šç”¨æ£‹ç±»å¯¹æˆ˜å¹³å° (Webç‰ˆ)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: #333;
        }

        .controls {
            margin-bottom: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        button {
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button.secondary {
            background-color: #2196F3;
        }

        button.secondary:hover {
            background-color: #0b7dda;
        }

        button.danger {
            background-color: #f44336;
        }

        button.danger:hover {
            background-color: #d32f2f;
        }

        #game-container {
            position: relative;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            background-color: #E3CF57;
            cursor: crosshair;
            display: block;
        }

        #status-bar {
            margin-top: 10px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            height: 30px;
        }

        #message-area {
            color: #d32f2f;
            font-weight: bold;
            margin-top: 5px;
            height: 20px;
        }
    </style>
</head>

<body>

    <h1>é€šç”¨æ£‹ç±»å¯¹æˆ˜å¹³å°</h1>

    <div class="controls">
        <button onclick="startGame(1, 15)">å¼€å§‹äº”å­æ£‹ (15è·¯)</button>
        <button onclick="startGame(2, 19)">å¼€å§‹å›´æ£‹ (19è·¯)</button>
        <button class="secondary" onclick="undo()">æ‚”æ£‹</button>
        <button class="secondary" onclick="passTurn()">è™šç€ (ä»…å›´æ£‹)</button>
        <button class="danger" onclick="resetGame()">é‡ç½®/ç»“æŸ</button>
    </div>

    <div id="status-bar">è¯·é€‰æ‹©æ¸¸æˆæ¨¡å¼å¼€å§‹</div>
    <div id="message-area"></div>

    <div id="game-container">
        <canvas id="boardCanvas" width="600" height="600"></canvas>
    </div>

    <script>
        // ================= å¸¸é‡å®šä¹‰ =================
        const PieceType = { EMPTY: 0, BLACK: 1, WHITE: 2 };
        const GameType = { GOMOKU: 1, GO: 2 };
        const CELL_SIZE = 30;
        const MARGIN = 30;

        // ================= æ¸¸æˆçŠ¶æ€ =================
        let gameState = {
            board: [],
            size: 15,
            currentPlayer: PieceType.BLACK,
            gameType: null,
            isGameOver: true,
            history: [],
            passCount: 0
        };

        const canvas = document.getElementById('boardCanvas');
        const ctx = canvas.getContext('2d');

        // ================= æ ¸å¿ƒé€»è¾‘ =================

        function initBoard(size) {
            let grid = [];
            for (let r = 0; r < size; r++) {
                let row = [];
                for (let c = 0; c < size; c++) row.push(PieceType.EMPTY);
                grid.push(row);
            }
            return grid;
        }

        function startGame(type, size) {
            gameState.gameType = type;
            gameState.size = size;
            gameState.board = initBoard(size);
            gameState.currentPlayer = PieceType.BLACK;
            gameState.isGameOver = false;
            gameState.history = [];
            gameState.passCount = 0;

            // è°ƒæ•´ç”»å¸ƒå¤§å°
            const dim = size * CELL_SIZE + MARGIN * 2;
            canvas.width = dim;
            canvas.height = dim;

            saveState();
            updateUI("æ¸¸æˆå¼€å§‹ï¼šé»‘æ–¹æ‰§é»‘å…ˆè¡Œ");
            drawBoard();
        }

        function saveState() {
            // æ·±æ‹·è´å½“å‰çŠ¶æ€å­˜å…¥å†å²
            const snapshot = {
                board: JSON.parse(JSON.stringify(gameState.board)),
                currentPlayer: gameState.currentPlayer,
                passCount: gameState.passCount,
                isGameOver: gameState.isGameOver
            };
            gameState.history.push(snapshot);
        }

        function undo() {
            if (gameState.history.length < 2) {
                showMessage("æ— æ³•æ‚”æ£‹ï¼šå·²æ˜¯åˆå§‹çŠ¶æ€");
                return;
            }
            gameState.history.pop(); // ç§»é™¤å½“å‰
            const lastState = gameState.history[gameState.history.length - 1];

            gameState.board = JSON.parse(JSON.stringify(lastState.board));
            gameState.currentPlayer = lastState.currentPlayer;
            gameState.passCount = lastState.passCount;
            gameState.isGameOver = lastState.isGameOver;

            updateUI("å·²æ‚”æ£‹");
            drawBoard();
        }

        function passTurn() {
            if (gameState.isGameOver) return;
            if (gameState.gameType !== GameType.GO) {
                showMessage("äº”å­æ£‹ä¸èƒ½è™šç€");
                return;
            }

            gameState.passCount++;
            switchPlayer();

            if (gameState.passCount >= 2) {
                endGame("åŒæ–¹è™šç€ï¼Œæ¸¸æˆç»“æŸ");
            } else {
                saveState();
                updateUI("ç©å®¶è™šç€ï¼Œæ¢æ‰‹");
                drawBoard();
            }
        }

        function resetGame() {
            gameState.isGameOver = true;
            gameState.board = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateUI("æ¸¸æˆå·²é‡ç½®");
        }

        function switchPlayer() {
            gameState.currentPlayer = gameState.currentPlayer === PieceType.BLACK ? PieceType.WHITE : PieceType.BLACK;
        }

        function showMessage(msg) {
            const el = document.getElementById('message-area');
            el.innerText = msg;
            setTimeout(() => el.innerText = "", 3000);
        }

        function updateUI(status) {
            const el = document.getElementById('status-bar');
            const pName = gameState.currentPlayer === PieceType.BLACK ? "é»‘æ–¹" : "ç™½æ–¹";
            if (gameState.isGameOver) {
                el.innerText = status;
            } else {
                el.innerText = `å½“å‰æ‰§å­: ${pName} | ${status || "è¿›è¡Œä¸­"}`;
            }
        }

        function endGame(reason) {
            gameState.isGameOver = true;
            saveState();
            updateUI(`ğŸ† ${reason}`);
            alert(reason);
        }

        // ================= äº¤äº’ä¸ç»˜å›¾ =================

        canvas.addEventListener('mousedown', (e) => {
            if (gameState.isGameOver || !gameState.board.length) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const c = Math.round((x - MARGIN) / CELL_SIZE);
            const r = Math.round((y - MARGIN) / CELL_SIZE);

            if (r >= 0 && r < gameState.size && c >= 0 && c < gameState.size) {
                makeMove(r, c);
            }
        });

        function makeMove(r, c) {
            if (gameState.board[r][c] !== PieceType.EMPTY) {
                showMessage("æ­¤å¤„å·²æœ‰æ£‹å­");
                return;
            }

            // 1. å°è¯•è½å­
            const originalBoard = JSON.parse(JSON.stringify(gameState.board));
            gameState.board[r][c] = gameState.currentPlayer;

            try {
                // 2. è§„åˆ™æ£€æŸ¥
                if (gameState.gameType === GameType.GO) {
                    processGoLogic(r, c);
                } else {
                    // äº”å­æ£‹åªéœ€æ£€æŸ¥æ˜¯å¦ç©ºï¼ˆå·²åšï¼‰
                }
            } catch (err) {
                gameState.board = originalBoard; // å›æ»š
                showMessage(err);
                return;
            }

            // 3. èƒœè´Ÿåˆ¤å®š
            gameState.passCount = 0;
            let win = false;
            if (gameState.gameType === GameType.GOMOKU) {
                win = checkGomokuWin(r, c, gameState.currentPlayer);
            }

            if (win) {
                const winner = gameState.currentPlayer === PieceType.BLACK ? "é»‘æ–¹è·èƒœ" : "ç™½æ–¹è·èƒœ";
                drawBoard();
                endGame(winner);
            } else {
                switchPlayer();
                saveState();
                updateUI();
                drawBoard();
            }
        }

        // --- äº”å­æ£‹é€»è¾‘ ---
        function checkGomokuWin(r, c, color) {
            const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
            for (let [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    if (getPiece(r + dr * i, c + dc * i) === color) count++; else break;
                }
                for (let i = 1; i < 5; i++) {
                    if (getPiece(r - dr * i, c - dc * i) === color) count++; else break;
                }
                if (count >= 5) return true;
            }
            return false;
        }

        // --- å›´æ£‹é€»è¾‘ (ç®€åŒ–ç‰ˆï¼šæå­ä¸è‡ªæ€æ£€æµ‹) ---
        function processGoLogic(r, c) {
            const opponent = gameState.currentPlayer === PieceType.BLACK ? PieceType.WHITE : PieceType.BLACK;
            let captured = false;

            // æ£€æŸ¥å››å‘¨å¯¹æ‰‹æ°”
            const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            dirs.forEach(([dr, dc]) => {
                const nr = r + dr, nc = c + dc;
                if (getPiece(nr, nc) === opponent) {
                    if (getLiberties(nr, nc) === 0) {
                        removeGroup(nr, nc, opponent);
                        captured = true;
                    }
                }
            });

            // è‡ªæ€æ£€æµ‹
            if (!captured && getLiberties(r, c) === 0) {
                throw "ç¦ç€ç‚¹ï¼šè‡ªæ€";
            }
        }

        function getPiece(r, c) {
            if (r < 0 || r >= gameState.size || c < 0 || c >= gameState.size) return -1;
            return gameState.board[r][c];
        }

        function getLiberties(r, c) {
            let color = gameState.board[r][c];
            let stack = [[r, c]];
            let visited = new Set([`${r},${c}`]);
            let liberties = 0;

            while (stack.length) {
                let [cr, cc] = stack.pop();
                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                    let nr = cr + dr, nc = cc + dc;
                    if (nr >= 0 && nr < gameState.size && nc >= 0 && nc < gameState.size) {
                        let p = gameState.board[nr][nc];
                        if (p === PieceType.EMPTY) {
                            if (!visited.has(`${nr},${nc}E`)) { // ç²—ç•¥å»é‡æ°”
                                liberties++;
                                visited.add(`${nr},${nc}E`);
                            }
                        } else if (p === color && !visited.has(`${nr},${nc}`)) {
                            visited.add(`${nr},${nc}`);
                            stack.push([nr, nc]);
                        }
                    }
                });
            }
            return liberties;
        }

        function removeGroup(r, c, color) {
            let stack = [[r, c]];
            gameState.board[r][c] = PieceType.EMPTY;
            while (stack.length) {
                let [cr, cc] = stack.pop();
                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                    let nr = cr + dr, nc = cc + dc;
                    if (nr >= 0 && nr < gameState.size && gameState.board[nr][nc] === color) {
                        gameState.board[nr][nc] = PieceType.EMPTY;
                        stack.push([nr, nc]);
                    }
                });
            }
        }

        // --- ç»˜å›¾ ---
        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!gameState.board.length) return;

            // ç”»çº¿
            ctx.beginPath();
            ctx.strokeStyle = "#000";
            for (let i = 0; i < gameState.size; i++) {
                // æ¨ªçº¿
                ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
                ctx.lineTo(MARGIN + (gameState.size - 1) * CELL_SIZE, MARGIN + i * CELL_SIZE);
                // ç«–çº¿
                ctx.moveTo(MARGIN + i * CELL_SIZE, MARGIN);
                ctx.lineTo(MARGIN + i * CELL_SIZE, MARGIN + (gameState.size - 1) * CELL_SIZE);
            }
            ctx.stroke();

            // ç”»å­
            for (let r = 0; r < gameState.size; r++) {
                for (let c = 0; c < gameState.size; c++) {
                    const p = gameState.board[r][c];
                    if (p !== PieceType.EMPTY) {
                        ctx.beginPath();
                        const x = MARGIN + c * CELL_SIZE;
                        const y = MARGIN + r * CELL_SIZE;
                        ctx.arc(x, y, CELL_SIZE / 2 - 2, 0, 2 * Math.PI);
                        ctx.fillStyle = p === PieceType.BLACK ? "black" : "white";
                        ctx.fill();
                        ctx.strokeStyle = "black"; // ç™½æ£‹æè¾¹
                        if (p === PieceType.WHITE) ctx.stroke();
                    }
                }
            }
        }
    </script>
</body>

</html>