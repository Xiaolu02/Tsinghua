<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ£‹ç±»å¯¹æˆ˜å¹³å° v7.0 (Webç‰ˆ)</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #f0f2f5;
            display: flex;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* å¸ƒå±€ */
        .sidebar {
            width: 300px;
            background: white;
            padding: 20px;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* ç»„ä»¶æ ·å¼ */
        h2 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }

        .panel {
            margin-bottom: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
            color: #555;
        }

        input,
        select,
        button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        /* æŒ‰é’®é¢œè‰² */
        button {
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            border: none;
            color: white;
        }

        .btn-primary {
            background-color: #4CAF50;
        }

        .btn-primary:hover {
            background-color: #45a049;
        }

        .btn-info {
            background-color: #2196F3;
        }

        .btn-info:hover {
            background-color: #1976D2;
        }

        .btn-warn {
            background-color: #ff9800;
        }

        .btn-warn:hover {
            background-color: #f57c00;
        }

        .btn-danger {
            background-color: #f44336;
        }

        .btn-danger:hover {
            background-color: #d32f2f;
        }

        .btn-group {
            display: flex;
            gap: 5px;
        }

        /* æ¸¸æˆç”»å¸ƒ */
        canvas {
            background-color: #E3CF57;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            cursor: crosshair;
        }

        /* çŠ¶æ€æ—¥å¿— */
        #log-area {
            width: 600px;
            height: 120px;
            margin-top: 15px;
            background: #2d2d2d;
            color: #0f0;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            padding: 10px;
            overflow-y: auto;
            border-radius: 4px;
        }

        /* ç”¨æˆ·çŠ¶æ€ */
        .user-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 5px;
            color: white;
        }

        .tag-p1 {
            background-color: #333;
        }

        .tag-p2 {
            background-color: #999;
            color: black;
        }

        /* æ¨¡æ€æ¡† (ç™»å½•) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 8px;
            width: 300px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>

    <div id="loginModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">ç”¨æˆ·ç™»å½•</h2>
            <input type="text" id="username" placeholder="ç”¨æˆ·å">
            <input type="password" id="password" placeholder="å¯†ç  (å·²éšè—)">
            <button class="btn-primary" onclick="userSys.login()">ç™»å½•</button>
            <button class="btn-info" onclick="userSys.register()">æ³¨å†Œ</button>
            <button class="btn-warn" onclick="userSys.guest()">æ¸¸å®¢è¯•ç©</button>
        </div>
    </div>

    <div class="sidebar">
        <h2>æ§åˆ¶é¢æ¿</h2>

        <div class="panel">
            <div id="p1-display">P1(é»‘): æœªç™»å½•</div>
            <div id="p2-display">P2(ç™½): AI</div>
            <button class="btn-info" style="margin-top:5px; font-size:0.8em;" onclick="userSys.showP2Login()">ç™»å½• P2 è´¦å·
                (åŒäººå¯¹æˆ˜)</button>
        </div>

        <div class="panel">
            <label>æ¸¸æˆæ¨¡å¼</label>
            <select id="gameType">
                <option value="1">äº”å­æ£‹ (15è·¯)</option>
                <option value="2">å›´æ£‹ (19è·¯)</option>
                <option value="3">é»‘ç™½æ£‹ (8è·¯)</option>
            </select>

            <label>å¯¹æ‰‹è®¾ç½®</label>
            <select id="p2Type">
                <option value="AI">AI (ç”µè„‘)</option>
                <option value="HUMAN">äººç±» (PVP)</option>
            </select>

            <label>AI éš¾åº¦</label>
            <select id="aiLevel">
                <option value="1">ç®€å• (éšæœº)</option>
                <option value="2" selected>å›°éš¾ (è´ªå¿ƒ)</option>
            </select>

            <button class="btn-primary" onclick="game.start()">å¼€å§‹æ–°æ¸¸æˆ</button>
        </div>

        <div class="panel">
            <label>æ¸¸æˆæ“ä½œ</label>
            <div class="btn-group">
                <button class="btn-warn" onclick="game.undo()">æ‚”æ£‹</button>
                <button class="btn-warn" onclick="game.pass()">è™šç€</button>
            </div>
            <button class="btn-danger" onclick="game.resign()">è®¤è¾“ (Resign)</button>
            <div class="btn-group">
                <button class="btn-info" onclick="storage.save()">ä¿å­˜å­˜æ¡£</button>
                <button class="btn-info" onclick="storage.load()">è¯»å–å­˜æ¡£</button>
            </div>
        </div>

        <div id="replayPanel" class="panel hidden">
            <label style="color:red;">å›æ”¾æ¨¡å¼</label>
            <div class="btn-group">
                <button class="btn-info" onclick="game.stepReplay(-1)">ä¸Šä¸€æ­¥</button>
                <button class="btn-info" onclick="game.stepReplay(1)">ä¸‹ä¸€æ­¥</button>
            </div>
            <button class="btn-danger" onclick="game.resume()">åœ¨æ­¤å¤„æ¥ç®¡ (Resume)</button>
            <button class="btn-warn" onclick="game.exitReplay()">é€€å‡ºå›æ”¾</button>
        </div>
    </div>

    <div class="main-area">
        <canvas id="board" width="600" height="600"></canvas>
        <div id="log-area">>> ç³»ç»Ÿå¯åŠ¨å®Œæˆ...<br>>> è¯·ç™»å½•ä»¥è®°å½•æˆ˜ç»©ã€‚</div>
    </div>

    <script>
        /**
         * ç§»æ¤è‡ª Python Final Platform v7.0
         * åŒ…å«ï¼šç”¨æˆ·ç®¡ç†ã€è§„åˆ™å¼•æ“ã€AIç­–ç•¥ã€çŠ¶æ€ç®¡ç†
         */

        // --- åŸºç¡€æšä¸¾ ---
        const Type = { EMPTY: 0, BLACK: 1, WHITE: 2 };
        const GameMode = { GOMOKU: 1, GO: 2, REVERSI: 3 };

        // --- ç”¨æˆ·ç³»ç»Ÿ (LocalStorage) ---
        const userSys = {
            currentUser: null, // P1
            secondUser: null,  // P2

            getDB() { return JSON.parse(localStorage.getItem('chess_users') || '{}'); },
            saveDB(db) { localStorage.setItem('chess_users', JSON.stringify(db)); },

            login(isP2 = false) {
                const u = isP2 ? prompt("P2 ç”¨æˆ·å:") : document.getElementById('username').value;
                const p = isP2 ? prompt("P2 å¯†ç :") : document.getElementById('password').value;
                if (!u || !p) return alert("è¾“å…¥ä¸èƒ½ä¸ºç©º");

                const db = this.getDB();
                if (db[u] && db[u].pwd === p) {
                    if (isP2) {
                        if (u === this.currentUser?.name) return alert("ä¸èƒ½ä¸è‡ªå·±å¯¹æˆ˜");
                        this.secondUser = db[u];
                        log(`[ç³»ç»Ÿ] P2 ç™»å½•æˆåŠŸ: ${u}`);
                        this.updateDisplay();
                    } else {
                        this.currentUser = db[u];
                        document.getElementById('loginModal').classList.add('hidden');
                        log(`[ç³»ç»Ÿ] æ¬¢è¿å›æ¥, ${u}ã€‚èƒœç‡: ${this.getRate(u)}`);
                        this.updateDisplay();
                    }
                } else {
                    alert("ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯");
                }
            },

            register() {
                const u = document.getElementById('username').value;
                const p = document.getElementById('password').value;
                if (!u || !p) return alert("è¾“å…¥ä¸èƒ½ä¸ºç©º");

                const db = this.getDB();
                if (db[u]) return alert("ç”¨æˆ·å·²å­˜åœ¨");

                db[u] = { name: u, pwd: p, wins: 0, total: 0 };
                this.saveDB(db);
                alert("æ³¨å†ŒæˆåŠŸï¼Œè¯·ç™»å½•");
            },

            guest() {
                this.currentUser = null;
                document.getElementById('loginModal').classList.add('hidden');
                log("[ç³»ç»Ÿ] æ¸¸å®¢æ¨¡å¼ç™»å½•");
                this.updateDisplay();
            },

            showP2Login() {
                this.login(true);
            },

            recordWin(winnerColor) {
                const db = this.getDB();
                let updated = false;

                // P1 ç»“ç®—
                if (this.currentUser && db[this.currentUser.name]) {
                    db[this.currentUser.name].total++;
                    if (winnerColor === Type.BLACK) db[this.currentUser.name].wins++;
                    this.currentUser = db[this.currentUser.name]; // æ›´æ–°å†…å­˜
                    updated = true;
                }

                // P2 ç»“ç®— (å¦‚æœæ˜¯åŒäººç™»å½•)
                if (this.secondUser && db[this.secondUser.name]) {
                    db[this.secondUser.name].total++;
                    if (winnerColor === Type.WHITE) db[this.secondUser.name].wins++;
                    this.secondUser = db[this.secondUser.name];
                    updated = true;
                }

                if (updated) {
                    this.saveDB(db);
                    this.updateDisplay();
                    log("[æ•°æ®] æˆ˜ç»©å·²æ›´æ–°åˆ°æœ¬åœ°æ•°æ®åº“");
                }
            },

            getRate(name) {
                const u = this.getDB()[name];
                if (!u || u.total === 0) return "0%";
                return ((u.wins / u.total) * 100).toFixed(1) + "%";
            },

            updateDisplay() {
                const p1Info = this.currentUser ? `${this.currentUser.name} [èƒœ:${this.currentUser.wins}/æ€»:${this.currentUser.total}]` : "æ¸¸å®¢";
                const p2Info = this.secondUser ? `${this.secondUser.name} [èƒœ:${this.secondUser.wins}/æ€»:${this.secondUser.total}]` : (game.p2IsAI ? "AI (ç”µè„‘)" : "äººç±» (æœªç™»å½•)");

                document.getElementById('p1-display').innerHTML = `<span class='user-tag tag-p1'>é»‘</span> ${p1Info}`;
                document.getElementById('p2-display').innerHTML = `<span class='user-tag tag-p2'>ç™½</span> ${p2Info}`;
            }
        };

        // --- è§„åˆ™å¼•æ“ ---
        const rules = {
            // åŸºç¡€æ£€æŸ¥
            inBounds: (b, r, c) => r >= 0 && r < b.length && c >= 0 && c < b.length,

            // é»‘ç™½æ£‹ç¿»è½¬é€»è¾‘
            reversi: {
                getFlips(board, r, c, color) {
                    const opp = color === Type.BLACK ? Type.WHITE : Type.BLACK;
                    const dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                    let flips = [];

                    for (let [dr, dc] of dirs) {
                        let temp = [], nr = r + dr, nc = c + dc;
                        while (rules.inBounds(board, nr, nc) && board[nr][nc] === opp) {
                            temp.push([nr, nc]); nr += dr; nc += dc;
                        }
                        if (rules.inBounds(board, nr, nc) && board[nr][nc] === color) {
                            flips.push(...temp);
                        }
                    }
                    return flips;
                }
            },

            // å›´æ£‹æ°”å’Œæå­
            go: {
                getGroup(board, r, c, color) {
                    let stack = [[r, c]], visited = new Set([`${r},${c}`]), liberties = 0;
                    let group = [[r, c]];
                    while (stack.length) {
                        let [cx, cy] = stack.pop();
                        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                            let nx = cx + dx, ny = cy + dy;
                            if (!rules.inBounds(board, nx, ny)) return;
                            if (board[nx][ny] === Type.EMPTY) {
                                if (!visited.has(`E${nx},${ny}`)) { liberties++; visited.add(`E${nx},${ny}`); }
                            } else if (board[nx][ny] === color && !visited.has(`${nx},${ny}`)) {
                                visited.add(`${nx},${ny}`); group.push([nx, ny]); stack.push([nx, ny]);
                            }
                        });
                    }
                    return { group, liberties };
                }
            },

            // äº”å­æ£‹åˆ¤èµ¢
            gomoku: {
                checkWin(board, r, c, color) {
                    const dirs = [[0, 1], [1, 0], [1, 1], [1, -1]];
                    for (let [dr, dc] of dirs) {
                        let count = 1;
                        for (let i = 1; i < 5; i++) if (rules.inBounds(board, r + dr * i, c + dc * i) && board[r + dr * i][c + dc * i] === color) count++; else break;
                        for (let i = 1; i < 5; i++) if (rules.inBounds(board, r - dr * i, c - dc * i) && board[r - dr * i][c - dc * i] === color) count++; else break;
                        if (count >= 5) return true;
                    }
                    return false;
                }
            }
        };

        // --- AI ç­–ç•¥ (ç§»æ¤ç‰ˆ) ---
        const ai = {
            getMove(board, mode, color, level) {
                let legalMoves = [];
                let size = board.length;

                // 1. æ‰¾æ‰€æœ‰åˆæ³•ç‚¹
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (board[r][c] !== Type.EMPTY) continue;
                        // è§„åˆ™æ ¡éªŒ
                        if (mode === GameMode.REVERSI) {
                            if (rules.reversi.getFlips(board, r, c, color).length > 0) legalMoves.push([r, c]);
                        } else if (mode === GameMode.GOMOKU) {
                            legalMoves.push([r, c]);
                        } else { // GO
                            // ç®€åŒ–ï¼šä¸å¡«çœ¼å³å¯
                            legalMoves.push([r, c]);
                        }
                    }
                }

                if (legalMoves.length === 0) return null;

                // Level 1: éšæœº
                if (level == 1) return legalMoves[Math.floor(Math.random() * legalMoves.length)];

                // Level 2: è´ªå¿ƒ
                if (mode === GameMode.REVERSI) {
                    let best = -999, moves = [];
                    for (let [r, c] of legalMoves) {
                        let score = rules.reversi.getFlips(board, r, c, color).length;
                        if ((r === 0 || r === 7) && (c === 0 || c === 7)) score += 100; // å è§’
                        if (score > best) { best = score; moves = [[r, c]]; }
                        else if (score === best) moves.push([r, c]);
                    }
                    return moves[Math.floor(Math.random() * moves.length)];
                }
                else if (mode === GameMode.GOMOKU) {
                    // ç®€å•ä¼°å€¼ï¼šè¶Šé è¿‘ä¸­å¿ƒåˆ†è¶Šé«˜ + è¿ç åˆ†
                    let best = -1, moves = [];
                    let mid = size / 2;
                    for (let [r, c] of legalMoves) {
                        let score = (size - Math.abs(r - mid) - Math.abs(c - mid));
                        // æ”»é˜²ä¼°å€¼çœç•¥ï¼Œä¿ç•™åŸºæœ¬ä½ç½®åˆ†
                        if (score > best) { best = score; moves = [[r, c]]; }
                        else if (score === best) moves.push([r, c]);
                    }
                    return moves[Math.floor(Math.random() * moves.length)];
                }

                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }
        };

        // --- æ¸¸æˆæ ¸å¿ƒæ§åˆ¶å™¨ ---
        const game = {
            board: [],
            size: 15,
            mode: 1,
            turn: Type.BLACK,
            history: [],
            isOver: true,
            passCount: 0,
            p2IsAI: true,
            aiLevel: 2,

            // å›æ”¾çŠ¶æ€
            isReplay: false,
            replayIdx: 0,
            replayData: [],

            initCanvas() {
                this.canvas = document.getElementById('board');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.addEventListener('mousedown', (e) => this.onClick(e));
            },

            start() {
                this.mode = parseInt(document.getElementById('gameType').value);
                this.p2IsAI = document.getElementById('p2Type').value === 'AI';
                this.aiLevel = parseInt(document.getElementById('aiLevel').value);

                // æ£‹ç›˜å¤§å°è®¾å®š
                if (this.mode === GameMode.GOMOKU) this.size = 15;
                if (this.mode === GameMode.GO) this.size = 19;
                if (this.mode === GameMode.REVERSI) this.size = 8;

                // åˆå§‹åŒ–
                this.board = Array(this.size).fill(0).map(() => Array(this.size).fill(0));
                this.turn = Type.BLACK;
                this.isOver = false;
                this.history = [];
                this.passCount = 0;
                this.isReplay = false;
                document.getElementById('replayPanel').classList.add('hidden');

                // é»‘ç™½æ£‹åˆå§‹å­
                if (this.mode === GameMode.REVERSI) {
                    let m = this.size / 2;
                    this.board[m - 1][m - 1] = Type.WHITE;
                    this.board[m][m] = Type.WHITE;
                    this.board[m - 1][m] = Type.BLACK;
                    this.board[m][m - 1] = Type.BLACK;
                }

                this.saveState(); // åˆå§‹çŠ¶æ€
                userSys.updateDisplay(); // æ›´æ–°æ˜¾ç¤ºï¼ˆP2å¯èƒ½ä»AIå˜äººï¼‰
                log(`[ç³»ç»Ÿ] æ¸¸æˆå¼€å§‹ï¼æ¨¡å¼: ${this.getModeName()}`);
                this.draw();

                // é»‘ç™½æ£‹å…ˆæ‰‹æ£€æŸ¥
                if (this.mode === GameMode.REVERSI) this.checkAutoPass();
            },

            getModeName() {
                return ["", "äº”å­æ£‹", "å›´æ£‹", "é»‘ç™½æ£‹"][this.mode];
            },

            onClick(e) {
                if (this.isOver || this.isReplay) return;
                if (this.turn === Type.WHITE && this.p2IsAI) return; // AIæ€è€ƒä¸­

                const rect = this.canvas.getBoundingClientRect();
                const cellSize = this.canvas.width / (this.size + (this.mode === 3 ? 0 : 1)); // è¾¹è·ä¿®æ­£
                const margin = cellSize / 2 + (this.mode === 3 ? 0 : 10); // ç®€å•å¯¹é½

                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // åæ ‡è½¬æ¢
                let c = Math.round((x - 30) / 35);
                let r = Math.round((y - 30) / 35);

                // åŠ¨æ€è®¡ç®—
                // ç®€å•å¤„ç†ï¼šWebç‰ˆå›ºå®šç»˜åˆ¶é€»è¾‘
                // å®é™…ç»˜åˆ¶ç”¨äº†å›ºå®šé—´éš”35
                c = Math.round((x - 30) / 35);
                r = Math.round((y - 30) / 35);

                if (r >= 0 && r < this.size && c >= 0 && c < this.size) {
                    this.attemptMove(r, c);
                }
            },

            attemptMove(r, c) {
                // 1. åŸºç¡€æ ¡éªŒ
                if (this.board[r][c] !== Type.EMPTY) return log("âŒ æ­¤å¤„å·²æœ‰æ£‹å­");

                // 2. è§„åˆ™æ ¡éªŒä¸æ‰§è¡Œ
                let captured = [];
                if (this.mode === GameMode.REVERSI) {
                    let flips = rules.reversi.getFlips(this.board, r, c, this.turn);
                    if (flips.length === 0) return log("âŒ å¿…é¡»å¤¹ä½å¯¹æ–¹æ£‹å­");
                    // æ‰§è¡Œç¿»è½¬
                    flips.forEach(([fr, fc]) => this.board[fr][fc] = this.turn);
                }
                else if (this.mode === GameMode.GO) {
                    // æå­é€»è¾‘æ¨¡æ‹Ÿ
                    let opp = this.turn === Type.BLACK ? Type.WHITE : Type.BLACK;
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        let nr = r + dr, nc = c + dc;
                        if (rules.inBounds(this.board, nr, nc) && this.board[nr][nc] === opp) {
                            let res = rules.go.getGroup(this.board, nr, nc, opp);
                            if (res.liberties === 0) { // æå­
                                res.group.forEach(([gr, gc]) => this.board[gr][gc] = Type.EMPTY);
                                captured.push(...res.group);
                            }
                        }
                    });
                    // è‡ªæ€æ£€æŸ¥
                    this.board[r][c] = this.turn; // å‡ä¸‹
                    let selfRes = rules.go.getGroup(this.board, r, c, this.turn);
                    if (selfRes.liberties === 0 && captured.length === 0) {
                        this.board[r][c] = Type.EMPTY; // è¿˜åŸ
                        return log("âŒ ç¦ç€ç‚¹ï¼šè‡ªæ€");
                    }
                }

                // è½å­
                this.board[r][c] = this.turn;
                this.passCount = 0;
                this.saveState({ r, c }); // è®°å½•

                // åˆ¤èƒœ (äº”å­æ£‹)
                if (this.mode === GameMode.GOMOKU && rules.gomoku.checkWin(this.board, r, c, this.turn)) {
                    return this.gameOver(this.turn, (this.turn === 1 ? "é»‘æ–¹" : "ç™½æ–¹") + "äº”è¿ç è·èƒœ");
                }

                // æ£‹ç›˜æ»¡
                if (!this.board.some(row => row.includes(Type.EMPTY))) {
                    if (this.mode !== GameMode.GO) return this.countScore("æ£‹ç›˜å·²æ»¡");
                }

                // æ¢æ‰‹
                this.turn = this.turn === Type.BLACK ? Type.WHITE : Type.BLACK;
                this.draw();

                // è§¦å‘AIæˆ–åˆæ³•æ€§æ£€æŸ¥
                setTimeout(() => this.nextStepLogic(), 100);
            },

            nextStepLogic() {
                if (this.isOver) return;

                // æ£€æŸ¥æ— å­å¯è½ (é»‘ç™½æ£‹)
                if (this.mode === GameMode.REVERSI || this.mode === GameMode.GO) {
                    this.checkAutoPass();
                    if (this.isOver) return; // å¦‚æœåŒpassç»“æŸ
                }

                // AIè¡ŒåŠ¨
                if (this.turn === Type.WHITE && this.p2IsAI) {
                    let move = ai.getMove(this.board, this.mode, this.turn, this.aiLevel);
                    if (move) this.attemptMove(move[0], move[1]);
                    else this.pass(); // AIæ— å­å¯ä¸‹
                }
            },

            checkAutoPass() {
                // ç®€å•æ£€æŸ¥æ˜¯å¦æœ‰åˆæ³•æ­¥
                let canMove = false;
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.board[r][c] !== Type.EMPTY) continue;
                        if (this.mode === GameMode.REVERSI) {
                            if (rules.reversi.getFlips(this.board, r, c, this.turn).length > 0) { canMove = true; break; }
                        } else {
                            canMove = true; break; // å›´æ£‹æ€»èƒ½ä¸‹
                        }
                    }
                    if (canMove) break;
                }

                if (!canMove) {
                    log(`[ç³»ç»Ÿ] ${this.turn === 1 ? "é»‘" : "ç™½"}æ–¹æ— å­å¯è½ï¼Œè‡ªåŠ¨è™šç€`);
                    this.pass();
                }
            },

            pass() {
                if (this.isOver) return;
                if (this.mode === GameMode.GOMOKU) return log("âŒ äº”å­æ£‹ä¸å…è®¸è™šç€");

                this.passCount++;
                log(`[æ“ä½œ] ${this.turn === 1 ? "é»‘" : "ç™½"}æ–¹ è™šç€(Pass)`);
                this.saveState(null);
                this.turn = this.turn === Type.BLACK ? Type.WHITE : Type.BLACK;

                if (this.passCount >= 2) {
                    this.countScore("åŒæ–¹è¿ç»­è™šç€ï¼Œæ¸¸æˆç»“æŸ");
                } else {
                    this.draw();
                    setTimeout(() => this.nextStepLogic(), 100);
                }
            },

            undo() {
                if (this.isReplay) return alert("å›æ”¾æ¨¡å¼æ— æ³•æ‚”æ£‹");
                if (this.history.length < 2) return alert("æ— æ³•æ‚”æ£‹");

                let steps = this.p2IsAI ? 2 : 1;
                if (this.history.length <= steps) steps = this.history.length - 1;

                for (let i = 0; i < steps; i++) this.history.pop();

                let last = this.history[this.history.length - 1];
                this.board = JSON.parse(JSON.stringify(last.board));
                this.turn = last.turn;
                this.isOver = false;
                this.passCount = 0;

                log("[æ“ä½œ] æ‚”æ£‹æˆåŠŸ");
                this.draw();
            },

            resign() {
                if (this.isOver) return;
                let winner = this.turn === Type.BLACK ? Type.WHITE : Type.BLACK;
                this.gameOver(winner, `${this.turn === 1 ? "é»‘" : "ç™½"}æ–¹è®¤è¾“`);
            },

            countScore(reason) {
                let b = 0, w = 0;
                this.board.forEach(r => r.forEach(p => { if (p === 1) b++; if (p === 2) w++; }));
                let winner = b > w ? Type.BLACK : (w > b ? Type.WHITE : Type.EMPTY);
                this.gameOver(winner, `${reason}ã€‚é»‘:${b} ç™½:${w}`);
            },

            gameOver(winner, msg) {
                this.isOver = true;
                log(`ğŸ† æ¸¸æˆç»“æŸ: ${msg}`);
                alert(msg);
                if (winner !== Type.EMPTY) userSys.recordWin(winner);
            },

            saveState(move) {
                this.history.push({
                    board: JSON.parse(JSON.stringify(this.board)),
                    turn: this.turn,
                    move: move
                });
            },

            // --- ç»˜åˆ¶ ---
            draw() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                // å›ºå®šå‚æ•°é€‚é… 600px
                const margin = 30;
                const cell = 35;

                // åŠ¨æ€é€‚é…ç”»å¸ƒå¤§å°
                const realDim = this.size * 35 + 60;
                this.canvas.width = realDim;
                this.canvas.height = realDim;

                ctx.fillStyle = "#E3CF57";
                ctx.fillRect(0, 0, realDim, realDim);

                // ç½‘æ ¼
                ctx.beginPath();
                ctx.strokeStyle = "black";
                let offset = this.mode === GameMode.REVERSI ? 17.5 : 0; // é»‘ç™½æ£‹æ ¼å†…è½å­
                let gridNum = this.mode === GameMode.REVERSI ? this.size + 1 : this.size;

                for (let i = 0; i < gridNum; i++) {
                    ctx.moveTo(margin, margin + i * cell);
                    ctx.lineTo(margin + (gridNum - 1) * cell, margin + i * cell);
                    ctx.moveTo(margin + i * cell, margin);
                    ctx.lineTo(margin + i * cell, margin + (gridNum - 1) * cell);
                }
                ctx.stroke();

                // æ£‹å­
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (this.board[r][c] !== Type.EMPTY) {
                            let x = margin + c * cell + offset;
                            let y = margin + r * cell + offset;

                            ctx.beginPath();
                            ctx.arc(x, y, 15, 0, 2 * Math.PI);
                            ctx.fillStyle = this.board[r][c] === Type.BLACK ? "black" : "white";
                            ctx.fill();
                            if (this.board[r][c] === Type.WHITE) ctx.stroke();

                            // æ ‡è®°æœ€åä¸€æ­¥
                            let last = this.isReplay
                                ? this.replayData[this.replayIdx]?.move
                                : this.history[this.history.length - 1]?.move;

                            if (last && last.r === r && last.c === c) {
                                ctx.fillStyle = "red";
                                ctx.beginPath();
                                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                    }
                }
            },

            // --- å­˜æ¡£å›æ”¾ ---
            loadReplay(data) {
                this.isReplay = true;
                this.replayData = data.history;
                this.mode = data.mode;
                this.size = data.size;
                this.replayIdx = 0;

                document.getElementById('replayPanel').classList.remove('hidden');
                this.updateReplayView();
                log("[ç³»ç»Ÿ] è¿›å…¥å›æ”¾æ¨¡å¼");
            },

            stepReplay(dir) {
                if (!this.isReplay) return;
                let next = this.replayIdx + dir;
                if (next >= 0 && next < this.replayData.length) {
                    this.replayIdx = next;
                    this.updateReplayView();
                }
            },

            updateReplayView() {
                let state = this.replayData[this.replayIdx];
                this.board = state.board;
                this.draw();
                log(`[å›æ”¾] æ­¥éª¤ ${this.replayIdx} / ${this.replayData.length - 1}`);
            },

            resume() {
                if (!this.isReplay) return;
                this.isReplay = false;
                this.isOver = false;
                document.getElementById('replayPanel').classList.add('hidden');

                // æ¢å¤å†å²æ ˆ
                this.history = this.replayData.slice(0, this.replayIdx + 1);
                let current = this.history[this.history.length - 1];
                this.turn = current.turn;
                this.board = JSON.parse(JSON.stringify(current.board)); // æ·±æ‹·è´é˜²æ­¢å¼•ç”¨é—®é¢˜

                log("[ç³»ç»Ÿ] å·²æ¥ç®¡æ¯”èµ›ï¼Œè¯·ç»§ç»­ä¸‹æ£‹");
                this.draw();
                // æ¢å¤åå¦‚æœæ˜¯AIå›åˆ
                if (this.turn === Type.WHITE && this.p2IsAI) setTimeout(() => this.nextStepLogic(), 500);
            },

            exitReplay() {
                this.isReplay = false;
                document.getElementById('replayPanel').classList.add('hidden');
                this.start(); // é‡ç½®å›æ–°æ¸¸æˆç•Œé¢
            }
        };

        // --- å­˜å‚¨ç®¡ç† ---
        const storage = {
            save() {
                if (game.history.length === 0) return alert("ç©ºå±€æ— æ³•ä¿å­˜");
                const name = prompt("å­˜æ¡£å‘½å:", "game_" + new Date().getTime());
                if (!name) return;

                const data = {
                    history: game.history,
                    mode: game.mode,
                    size: game.size,
                    p1: userSys.currentUser?.name,
                    p2: userSys.secondUser?.name || "AI"
                };
                localStorage.setItem('save_' + name, JSON.stringify(data));
                log(`[ç³»ç»Ÿ] å­˜æ¡£ ${name} ä¿å­˜æˆåŠŸ`);
            },

            load() {
                // ç®€å•çš„éå†æ‰€æœ‰å­˜æ¡£
                let saves = [];
                for (let i = 0; i < localStorage.length; i++) {
                    let k = localStorage.key(i);
                    if (k.startsWith('save_')) saves.push(k.replace('save_', ''));
                }
                if (saves.length === 0) return alert("æ²¡æœ‰å­˜æ¡£");

                let name = prompt("è¾“å…¥å­˜æ¡£å:\n" + saves.join("\n"));
                if (!name) return;

                let json = localStorage.getItem('save_' + name);
                if (!json) return alert("å­˜æ¡£ä¸å­˜åœ¨");

                let data = JSON.parse(json);
                // æƒé™æ£€æŸ¥
                const curr = userSys.currentUser?.name;
                if (data.p1 && curr && data.p1 !== curr && data.p2 !== curr) {
                    if (!confirm(`âš ï¸ è­¦å‘Š: æ­¤å­˜æ¡£å±äº ${data.p1} å’Œ ${data.p2}ï¼Œä½ ç¡®å®šè¦è¯»å–å—?`)) return;
                }

                game.loadReplay(data);
            }
        };

        function log(msg) {
            const el = document.getElementById('log-area');
            el.innerHTML += `<div>${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        // åˆå§‹åŒ–
        game.initCanvas();
    </script>
</body>

</html>